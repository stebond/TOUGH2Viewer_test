/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Tough2ViewerPRJ;

import static Tough2ViewerPRJ.Tough2Viewer.toLogFile;
import java.io.*;
import java.text.DecimalFormat;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.vecmath.Point3d;

/**
 *
 * @author stebond
 */
public class InputBoxVoroPlusPlus extends javax.swing.JFrame {

    String FilePathString;
    String tough2viewer_dat_file_name = "none";
    String MESH_file_name = "none";
    String T2_data_file_name = "none";
    String INCON_file_name = "none";

//data: ArrayList containing the tough2viewer.dat file information
    ArrayList data = new ArrayList();

    ArrayList dataMESH = new ArrayList();
    String[] block_names;
    int[] block_index;
    double xmin = +1.0E50;
    double xmax = -1.0E50;
    double ymin = +1.0E50;
    double ymax = -1.0E50;
    double zmin = +1.0E50;
    double zmax = -1.0E50;

    /**
     * Creates new form VoroPlusPlus
     */
    public InputBoxVoroPlusPlus() {
        initComponents();
        readINIPathFile();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jProgressBar1 = new javax.swing.JProgressBar();
        jButton6 = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jButtonLoadVoroPlusPlus = new javax.swing.JButton();
        Preview = new javax.swing.JButton();
        jButtonTough2file = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jButtonIncon = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        jBtnMesh = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jButtonConvert2MESH = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Open unstructured V++ grid");

        jButton6.setText("Close");
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Input model"));

        jButtonLoadVoroPlusPlus.setText("File ...");
        jButtonLoadVoroPlusPlus.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonLoadVoroPlusPlusActionPerformed(evt);
            }
        });

        Preview.setText("3DPreview...");
        Preview.setEnabled(false);
        Preview.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PreviewActionPerformed(evt);
            }
        });

        jButtonTough2file.setText("Tough2 File...");
        jButtonTough2file.setEnabled(false);
        jButtonTough2file.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTough2fileActionPerformed(evt);
            }
        });

        jLabel1.setText("tough2viewer.dat");

        jLabel3.setText("MESH file");

        jLabel4.setText("T2 Output file");

        jButtonIncon.setText("INCON ...");
        jButtonIncon.setEnabled(false);
        jButtonIncon.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonInconActionPerformed(evt);
            }
        });

        jButton2.setText("CreateEmptyModel");
        jButton2.setToolTipText("");
        jButton2.setEnabled(false);
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton1.setText("Load last");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jBtnMesh.setText("MESH File ...");
        jBtnMesh.setEnabled(false);
        jBtnMesh.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBtnMeshActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel3)
                            .addComponent(jLabel4))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButtonIncon, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButtonTough2file, javax.swing.GroupLayout.DEFAULT_SIZE, 129, Short.MAX_VALUE)
                    .addComponent(jButtonLoadVoroPlusPlus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jBtnMesh, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(Preview, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton2))
                .addContainerGap())
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {Preview, jButton2});

        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton1)
                .addGap(4, 4, 4)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonLoadVoroPlusPlus)
                    .addComponent(Preview)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jBtnMesh)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jButton2)
                    .addComponent(jButtonTough2file))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButtonIncon)
                .addContainerGap())
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Export model"));

        jButtonConvert2MESH.setText("Export2CSV");
        jButtonConvert2MESH.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonConvert2MESHActionPerformed(evt);
            }
        });

        jButton4.setText("Export2VTK");
        jButton4.setEnabled(false);
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jButton3.setText("Convert2PLY");
        jButton3.setEnabled(false);
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton5.setText("Export2VTU");
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jButtonConvert2MESH, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jButton5, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel2Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jButton3, jButton4, jButton5});

        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton5)
                    .addComponent(jButtonConvert2MESH))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jProgressBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(jButton6, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(20, 20, 20))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(52, 52, 52)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(40, 40, 40)
                .addComponent(jButton6)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonLoadVoroPlusPlusActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonLoadVoroPlusPlusActionPerformed
        final JFileChooser fc = new JFileChooser(FilePathString);
        fc.setDialogTitle("Open tough2viewer.dat");
        int returnVal = fc.showOpenDialog(InputBoxVoroPlusPlus.this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            FilePathString = fc.getCurrentDirectory().toString();
            File file = fc.getSelectedFile();
            String fileName = file.getName();
            Tough2Viewer.dataobj.tough2viewer_dat_file_name = fileName;

            String FilePath = file.getAbsolutePath();
            Tough2Viewer.dataobj.tough2viewerdatfile = new ArrayList();
            if (read_tough2viewer_file(file)) {
                Preview.setEnabled(true);
                jBtnMesh.setEnabled(true);
                jButton3.setEnabled(true);
                jButton4.setEnabled(true);
                tough2viewer_dat_file_name = file.getAbsolutePath();
            } else {
                String error = "Error while reading" + fileName + ". Operation aborted";
                JOptionPane.showMessageDialog(null, error);
                Preview.setEnabled(false);
            }

        }
        Tough2Viewer.dataobj.VoroPPData = data;
        Tough2Viewer.dataobj.ID_grid_type = 2;
    }//GEN-LAST:event_jButtonLoadVoroPlusPlusActionPerformed

    private void PreviewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PreviewActionPerformed
        if (Tough2Viewer.tough2viewerGUI.voro3D == null) {

            Tough2Viewer.tough2viewerGUI.voro3D = new VoroPlusPlus3D(data, xmin, xmax, ymin, ymax, zmin, zmax);

        }
        Tough2Viewer.tough2viewerGUI.voro3D.setVisible(true);
        //VoroPlusPlus3D a=new VoroPlusPlus3D(data,xmin,xmax,ymin,ymax,zmin,zmax);
        //a.setVisible(true);
    }//GEN-LAST:event_PreviewActionPerformed

    private void jButtonConvert2MESHActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonConvert2MESHActionPerformed
        double time_steps = 0.0;
        String lineaOUT;
        double number_of_variables = Tough2Viewer.dataobj.get_number_of_variables();
        if (Tough2Viewer.dataobj.get_dataLoaded()) {
            time_steps = Tough2Viewer.dataobj.get_TimeSteps();
        }
        int n_of_cells = data.size();

        for (int i_t = 0; i_t < time_steps; i_t++) {
            String fileCSV;
            if (Tough2Viewer.dataobj.get_dataLoaded()) {
                fileCSV = FilePathString + "\\out_" + Integer.toString(i_t) + ".csv";
            } else {
                fileCSV = FilePathString + "\\out.vtu";
            }
            try {
                //Open an output stream
                FileOutputStream fos = new FileOutputStream(fileCSV, false);
                //DataOutputStream dos = new DataOutputStream(fos);
                PrintStream ps;
                // Print a line of text
                ps = new PrintStream(fos);
                String[] var = Tough2Viewer.dataobj.getVariableName();
                lineaOUT = "ID;x;y;z;";
                for (int i_v = 0; i_v < number_of_variables; i_v++) {
                    lineaOUT = lineaOUT + var[i_v] + ";";
                }

                ps.println(lineaOUT);
                for (int i = 0; i < n_of_cells; i++) {
                    lineaOUT = Integer.toString(i) + ";" + Double.toString(Tough2Viewer.dataobj.get_Xo(i)) + ";" + Double.toString(Tough2Viewer.dataobj.get_Yo(i)) + ";" + Double.toString(Tough2Viewer.dataobj.get_Zo(i)) + ";";
                    for (int i_v = 0; i_v < number_of_variables; i_v++) {
                        float value = Tough2Viewer.dataobj.get_dataArray(i, i_t, i_v);
                        lineaOUT = lineaOUT + Double.toString(value) + ";";

                    }
                    ps.println(lineaOUT);
                }
            } // Catches any error conditions
            catch (IOException e) {
                String output = "Unable to write out.csv file";
                Tough2Viewer.toLogFile(output);
                JOptionPane.showMessageDialog(null, output);
            }
        }
        String message = "Writing files out_n.csv OK!!";
        JOptionPane.showMessageDialog(null, message);

    }//GEN-LAST:event_jButtonConvert2MESHActionPerformed

    private void jBtnMeshActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBtnMeshActionPerformed
        final JFileChooser fc = new JFileChooser(FilePathString);
        fc.setDialogTitle("Open Mesh");
        int returnVal = fc.showOpenDialog(InputBoxVoroPlusPlus.this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            FilePathString = fc.getCurrentDirectory().toString();
            File file = fc.getSelectedFile();
            String FilePath = file.getAbsolutePath();

            Tough2Viewer.dataobj.set_InFileName(FilePath);
            if (Tough2Viewer.dataobj.read_MESH_file(file, 2))//2:VORO++ mesh
            {

                jBtnMesh.setEnabled(false);
                jButtonTough2file.setEnabled(true);
                Tough2Viewer.dataobj.ID_grid_type = 2;
                jButtonTough2file.setEnabled(true);
                jButton2.setEnabled(true);
                jButton4.setEnabled(true);
                MESH_file_name = file.getAbsolutePath();
            }
        }
    }//GEN-LAST:event_jBtnMeshActionPerformed
    private void CreateEmptyModel() {
        String fileName = "none";
        Tough2Viewer.dataobj.set_DataFileName(fileName);
        int nxyz = Tough2Viewer.dataobj.get_nxyz();
        int timesteptotal = 1;
        int n_var = 6;
        Tough2Viewer.dataobj.set_number_of_variables(n_var);
        String[] pippo = {"volume", "connections", "ID_T2V", "ID_prog", "num_vertex", "number_of_faces"};
        String[] pippoUM = {"volume", "connections", "ID_T2V", "ID_prog", "number", "number"};
        Tough2Viewer.dataobj.set_VariableName(pippo);
        Tough2Viewer.dataobj.set_variables_UM(pippoUM);
        Tough2Viewer.dataobj.dataArrayCreate(nxyz, timesteptotal);

        for (int i = 0; i < nxyz; i++) {
            for (int i_t = 0; i_t < timesteptotal; i_t++) {
                Tough2Viewer.dataobj.set_dataArray(i, i_t, 0, (float) Tough2Viewer.dataobj.get_BlockVolume(i));
                Tough2Viewer.dataobj.set_dataArray(i, i_t, 1, Tough2Viewer.dataobj.Block_n_conne[i]);
                ArrayList singleBox_0 = (ArrayList) Tough2Viewer.dataobj.VoroPPData.get(i);
                int ID_T2V = (Integer) singleBox_0.get(0);
                Tough2Viewer.dataobj.set_dataArray(i, i_t, 2, (float) ID_T2V);
                Tough2Viewer.dataobj.set_dataArray(i, i_t, 3, (float) i);
                ArrayList singleBox = (ArrayList) data.get(i);
                int num_vertex = (Integer) singleBox.get(2);
                int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                Tough2Viewer.dataobj.set_dataArray(i, i_t, 4, (float) num_vertex);
                Tough2Viewer.dataobj.set_dataArray(i, i_t, 5, (float) number_of_faces);

            }
        }
        Tough2Viewer.dataobj.set_dataLoaded(true);
        jButtonTough2file.setEnabled(true);
        Tough2Viewer.dataobj.set_voronoi(true);
        Tough2Viewer.dataobj.ID_grid_type = 2;
        Tough2Viewer.tough2viewerGUI.UpdateFileInformation();
        Tough2Viewer.dataobj.set_INIT_ROI();
        if (Tough2Viewer.dataobj.get_dataLoaded()) {
            toINIPathFile();
            Tough2Viewer.dataobj.set_WorkingPath(FilePathString);
        }
        jButtonTough2file.setEnabled(false);
        jButtonIncon.setEnabled(true);
    }

    public void readINIPathFile() {

        boolean exists = (new File("path.ini")).exists();
        if (exists) {
            File file = new File("path.ini");
            FileInputStream fis = null;
            BufferedInputStream bis = null;
            DataInputStream dis = null;
            String linea;
            int num_url = 0;
            try {
                fis = new FileInputStream(file);
                bis = new BufferedInputStream(fis);
                dis = new DataInputStream(bis);
                while (dis.available() != 0) {
                    FilePathString = (String) dis.readLine();
                    //era linea=...
                }
                fis.close();
                bis.close();
                dis.close();
            } catch (IOException e) {
                //e.printStackTrace();
                Tough2Viewer.toLogFile("Impossibile trovare il file path.ini");
            }
        }
    }

    public void toINIPathFile() {
        String strFilePath = "path.ini";
        try {
            // Open an output stream
            FileOutputStream fos = new FileOutputStream(strFilePath, true);
            PrintStream ps;
            // Print a line of text
            ps = new PrintStream(fos);
            ps.println(FilePathString);
            fos.close();
        } // Catches any error conditions
        catch (IOException e) {
            String output = "Unable to write file";
            Tough2Viewer.toLogFile(output);
            System.exit(-1);
        }
    }
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        CreateEmptyModel();
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButtonTough2fileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTough2fileActionPerformed
        String workingDir = Tough2Viewer.dataobj.get_WorkingPath();
        final JFileChooser fc = new JFileChooser(workingDir);
        fc.setDialogTitle("Open simulated");
        int returnVal = fc.showOpenDialog(InputBoxVoroPlusPlus.this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            String fileName = file.getName();
            Tough2Viewer.dataobj.set_DataFileName(fileName);
            String FilePath = file.getAbsolutePath();
            T2_data_file_name = file.getAbsolutePath();
            FilePathString = FilePath.substring(0, FilePath.length() - fileName.length());
            Tough2Viewer.dataobj.set_DataFilePath(FilePathString);
            Tough2Viewer.dataobj.set_WorkingPath(FilePathString);
            //start to read file
            ReadDataFileActivity1 readactivity = new ReadDataFileActivity1(10, FilePath, jProgressBar1);
            readactivity.execute();
            Tough2Viewer.dataobj.ID_grid_type = 2;
            Tough2Viewer.dataobj.set_dataLoaded(true);
            Tough2Viewer.dataobj.initializeRockType();
            toINIPathFile();

            jButtonIncon.setEnabled(true);
        }
    }//GEN-LAST:event_jButtonTough2fileActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        String filePLY = FilePathString + "\\out.ply";
        int n_of_cells = data.size();
        int total_vertex = 0;
        int total_faces = 0;
        String lineaOUT;
        for (int i = 0; i < n_of_cells; i++) {
            ArrayList singleBox = (ArrayList) data.get(i);
            int num_vertex = (Integer) singleBox.get(2);
            int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
            total_vertex = total_vertex + num_vertex;
            total_faces = total_faces + number_of_faces;
        }
        //writing header
        try {
            //Open an output stream
            FileOutputStream fos = new FileOutputStream(filePLY, true);
            //DataOutputStream dos = new DataOutputStream(fos);
            PrintStream ps;
            // Print a line of text
            ps = new PrintStream(fos);
            lineaOUT = "ply";
            ps.println(lineaOUT);
            lineaOUT = "format ascii 1.0";
            ps.println(lineaOUT);
            lineaOUT = "comment Exported by TOUGH2Viewer";
            ps.println(lineaOUT);
            lineaOUT = "element vertex " + Integer.toString(total_vertex);
            ps.println(lineaOUT);
            lineaOUT = "property float x";
            ps.println(lineaOUT);
            lineaOUT = "property float y";
            ps.println(lineaOUT);
            lineaOUT = "property float z";
            ps.println(lineaOUT);
            lineaOUT = "element face " + Integer.toString(total_faces);
            ps.println(lineaOUT);
            lineaOUT = "property list uchar int vertex_index";
            ps.println(lineaOUT);
            lineaOUT = "end_header";
            ps.println(lineaOUT);
            //starting write vertex
            //we write also duplicates...
            for (int j = 0; j < n_of_cells; j++) {
                ArrayList singleBox = (ArrayList) data.get(j);
                int num_vertex = (Integer) singleBox.get(2);
                double[] centerD = (double[]) singleBox.get(1);//POS=1
                num_vertex = (Integer) singleBox.get(2);
                Point3d[] vertex = new Point3d[num_vertex];
                for (int i = 0; i < num_vertex; i++) {
                    double[] v = (double[]) singleBox.get(3 + i);
                    vertex[i] = new Point3d(v[0] + centerD[0], v[1] + centerD[1], v[2] + centerD[2]);
                    lineaOUT = Double.toString(vertex[i].x) + " " + Double.toString(vertex[i].y) + " " + Double.toString(vertex[i].z);
                    ps.println(lineaOUT);
                }
            }
            //startin write faces
            //faces start from 0....
            int global_index = 0;
            for (int j = 0; j < n_of_cells; j++) {
                ArrayList singleBox = (ArrayList) data.get(j);
                int num_vertex = (Integer) singleBox.get(2);
                int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                for (int i = 0; i < number_of_faces; i++) {
                    //COMPLETARE QUI
                    int[] indexs = (int[]) singleBox.get(4 + num_vertex + i);
                    //ora so quanti vertici ha questa faccia:
                    int n_vertex_of_face = indexs.length;
                    lineaOUT = Integer.toString(n_vertex_of_face) + " ";
                    for (int j1 = 0; j1 < n_vertex_of_face; j1++) {
                        lineaOUT = lineaOUT + Integer.toString(global_index + indexs[j1]) + " ";
                    }
                    ps.println(lineaOUT);

                }
                global_index = global_index + num_vertex;
            }

            fos.close();
        } // Catches any error conditions
        catch (IOException e) {
            String output = "Unable to write file";
            Tough2Viewer.toLogFile(output);
        }
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        int time_steps = 1;
        if (Tough2Viewer.dataobj.get_dataLoaded()) {
            time_steps = Tough2Viewer.dataobj.get_TimeSteps();

        }
        for (int i_t = 0; i_t < time_steps; i_t++) {
            String filePLY = "";
            if (Tough2Viewer.dataobj.get_dataLoaded()) {
                filePLY = FilePathString + "\\out_" + Integer.toString(i_t) + ".vtk";
            } else {
                filePLY = FilePathString + "\\out.vtk";
            }
            int n_of_cells = data.size();
            int total_vertex = 0;
            int total_faces = 0;
            int total_indexes = 0;
            String lineaOUT;
            for (int i = 0; i < n_of_cells; i++) {
                ArrayList singleBox = (ArrayList) data.get(i);
                int num_vertex = (Integer) singleBox.get(2);
                int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                for (int i1 = 0; i1 < number_of_faces; i1++) {
                    //COMPLETARE QUI
                    int[] indexs = (int[]) singleBox.get(4 + num_vertex + i1);
                    total_indexes = total_indexes + indexs.length;
                }
                total_vertex = total_vertex + num_vertex;
                total_faces = total_faces + number_of_faces;
            }
            //writing header
            try {
                //Open an output stream
                FileOutputStream fos = new FileOutputStream(filePLY, true);
                //DataOutputStream dos = new DataOutputStream(fos);
                PrintStream ps;
                // Print a line of text
                ps = new PrintStream(fos);
                lineaOUT = "# vtk DataFile Version 2.0 ";
                ps.println(lineaOUT);
                lineaOUT = "comment Exported by TOUGH2Viewer";
                ps.println(lineaOUT);
                lineaOUT = "ASCII";
                ps.println(lineaOUT);
                lineaOUT = "DATASET POLYDATA";
                ps.println(lineaOUT);
                lineaOUT = "POINTS " + Integer.toString(total_vertex) + " float";
                ps.println(lineaOUT);
                //starting write vertex
                //we write also duplicates...
                for (int j = 0; j < n_of_cells; j++) {
                    ArrayList singleBox = (ArrayList) data.get(j);
                    int num_vertex = (Integer) singleBox.get(2);
                    double[] centerD = (double[]) singleBox.get(1);//POS=1
                    num_vertex = (Integer) singleBox.get(2);
                    Point3d[] vertex = new Point3d[num_vertex];
                    for (int i = 0; i < num_vertex; i++) {
                        double[] v = (double[]) singleBox.get(3 + i);
                        vertex[i] = new Point3d(v[0] + centerD[0], v[1] + centerD[1], v[2] + centerD[2]);
                        lineaOUT = Double.toString(vertex[i].x) + " " + Double.toString(vertex[i].y) + " " + Double.toString(vertex[i].z);
                        ps.println(lineaOUT);
                    }
                }
                //startin write faces
                //faces start from 0....
                lineaOUT = "POLYGONS " + Integer.toString(total_faces) + " " + Integer.toString(total_faces + total_indexes);
                ps.println(lineaOUT);
                int global_index = 0;
                for (int j = 0; j < n_of_cells; j++) {
                    ArrayList singleBox = (ArrayList) data.get(j);
                    int num_vertex = (Integer) singleBox.get(2);
                    int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                    for (int i = 0; i < number_of_faces; i++) {
                        //COMPLETARE QUI
                        int[] indexs = (int[]) singleBox.get(4 + num_vertex + i);
                        //ora so quanti vertici ha questa faccia:
                        int n_vertex_of_face = indexs.length;
                        lineaOUT = Integer.toString(n_vertex_of_face) + " ";
                        for (int j1 = 0; j1 < n_vertex_of_face; j1++) {
                            lineaOUT = lineaOUT + Integer.toString(global_index + indexs[j1]) + " ";
                        }
                        ps.println(lineaOUT);

                    }
                    global_index = global_index + num_vertex;
                }
                if (jButtonTough2file.isEnabled()) {
                    lineaOUT = "CELL_DATA " + Integer.toString(total_faces);
                    ps.println(lineaOUT);
                    lineaOUT = "SCALARS rocktype int 1 ";
                    ps.println(lineaOUT);
                    lineaOUT = "LOOKUP_TABLE default";
                    ps.println(lineaOUT);
                    for (int j = 0; j < n_of_cells; j++) {
                        ArrayList singleBox = (ArrayList) data.get(j);
                        int num_vertex = (Integer) singleBox.get(2);
                        int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                        int rocktype = Tough2Viewer.dataobj.get_RockType(j);
                        for (int i = 0; i < number_of_faces; i++) {
                            lineaOUT = Integer.toString(rocktype);
                            ps.println(lineaOUT);
                        }
                    }

                }
                if (Tough2Viewer.dataobj.get_dataLoaded()) {
                    int number_of_variables = Tough2Viewer.dataobj.get_number_of_variables();

                    lineaOUT = "FIELD FieldData " + Integer.toString(number_of_variables);
                    ps.println(lineaOUT);
                    String[] var = Tough2Viewer.dataobj.getVariableName();
                    for (int i_v = 0; i_v < number_of_variables; i_v++) {
                        lineaOUT = var[i_v] + " 1 " + Integer.toString(total_faces) + " float";
                        ps.println(lineaOUT);
                        for (int j = 0; j < n_of_cells; j++) {
                            ArrayList singleBox = (ArrayList) data.get(j);
                            int num_vertex = (Integer) singleBox.get(2);
                            int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                            float value = Tough2Viewer.dataobj.get_dataArray(j, i_t, i_v);;
                            lineaOUT = "";

                            for (int i = 0; i < number_of_faces; i++) {
                                lineaOUT = lineaOUT + " " + Float.toString(value);

                            }
                            ps.println(lineaOUT);
                        }
                    }
                }
                fos.close();
            } // Catches any error conditions
            catch (IOException e) {
                String output = "Unable to write file";
                Tough2Viewer.toLogFile(output);
            }
        }
    }//GEN-LAST:event_jButton4ActionPerformed

    private void jButtonInconActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonInconActionPerformed
        OpenInconFrm InconFrame = new OpenInconFrm();
        InconFrame.setVisible(true);
    }//GEN-LAST:event_jButtonInconActionPerformed

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        int time_steps = 1;
        ArrayList faceOffset = new ArrayList();
        ArrayList pointOffset = new ArrayList();
        int rangemax_faces = 0;
        if (Tough2Viewer.dataobj.get_dataLoaded()) {
            time_steps = Tough2Viewer.dataobj.get_TimeSteps();
        }
        String suffix = "";
        int len1 = Tough2Viewer.dataobj.tough2viewer_dat_file_name.length();
        int len2 = "tough2viewer".length();
        if (len1 > len2) {
            suffix = Tough2Viewer.dataobj.tough2viewer_dat_file_name.substring(len2, len1 - 4);
        }
        String fileVTU = "";

        for (int i_t = 0; i_t < time_steps; i_t++) {

            if (Tough2Viewer.dataobj.get_dataLoaded()) {
                fileVTU = FilePathString + "\\out_" + Integer.toString(i_t) + suffix + ".vtu";
            } else {
                fileVTU = FilePathString + "\\out" + suffix + ".vtu";
            }
            int n_of_cells = data.size();
            int total_vertex = 0;
            int total_faces = 0;
            int total_indexes = 0;
            String lineaOUT;
            int global_index = 0;
            int face_offset = 0;
            for (int i = 0; i < n_of_cells; i++) {
                ArrayList singleBox = (ArrayList) data.get(i);
                int num_vertex = (Integer) singleBox.get(2);
                int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                face_offset++;
                for (int i1 = 0; i1 < number_of_faces; i1++) {
                    //COMPLETARE QUI
                    face_offset++;
                    int[] indexs = (int[]) singleBox.get(4 + num_vertex + i1);
                    total_indexes = total_indexes + indexs.length;
                    int n_vertex_of_face = indexs.length;
                    face_offset = face_offset + n_vertex_of_face;
                    for (int j1 = 0; j1 < n_vertex_of_face; j1++) {
                        int tmp_faces = global_index + indexs[j1];
                        if (tmp_faces > rangemax_faces) {
                            rangemax_faces = tmp_faces;
                        }

                    }
                }
                total_vertex = total_vertex + num_vertex;
                pointOffset.add(total_vertex);
                total_faces = total_faces + number_of_faces;
                global_index = global_index + num_vertex;
                faceOffset.add(face_offset);
            }
            //writing header
            try {
                //Open an output stream
                FileOutputStream fos = new FileOutputStream(fileVTU, false);
                //DataOutputStream dos = new DataOutputStream(fos);
                PrintStream ps;
                // Print a line of text
                ps = new PrintStream(fos);

                lineaOUT = "<?xml version=\"1.0\"?>";
                ps.println(lineaOUT);
                lineaOUT = "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">";
                ps.println(lineaOUT);
                lineaOUT = "  <UnstructuredGrid>";
                ps.println(lineaOUT);
                lineaOUT = "    <Piece NumberOfPoints=\"" + Integer.toString(total_vertex) + "\" NumberOfCells=\"" + Integer.toString(n_of_cells) + "\">";
                ps.println(lineaOUT);
                lineaOUT = "      <PointData>";
                ps.println(lineaOUT);
                lineaOUT = "      </PointData>";
                ps.println(lineaOUT);
                if (Tough2Viewer.dataobj.mesh_file_is_loaded)//this imply that we have no output data...
                {

                    lineaOUT = "      <CellData Scalars=\"TOUGH2\">";
                    ps.println(lineaOUT);
                    int n_rockstype = Tough2Viewer.dataobj.getRockTypesNumber();
                    lineaOUT = "        <DataArray type=\"Float32\" Name=\"RockTypes\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"" + Integer.toString(n_rockstype - 1) + "\">";
                    ps.println(lineaOUT);
                    lineaOUT = "          ";
                    int i_tmp = 0;
                    for (int j = 0; j < n_of_cells; j++) {
                        int rocktype = Tough2Viewer.dataobj.get_RockType(j);
                        lineaOUT = lineaOUT + Integer.toString(rocktype) + " ";
                        i_tmp++;
                        if (i_tmp == 5) {
                            ps.println(lineaOUT);
                            lineaOUT = "          ";
                            i_tmp = 0;
                        }
                    }
                    ps.println(lineaOUT);
                    lineaOUT = "        </DataArray>";
                    ps.println(lineaOUT);
                    //
                    //
                    //Printing IDs of the tough2viewer.dat file. This allow to understand what block is clicked/selected in paraview
                    //
                    //
                    ArrayList singleBox_0 = (ArrayList) Tough2Viewer.dataobj.VoroPPData.get(0);
                    int IDs_min = (int) singleBox_0.get(0);
                    ArrayList singleBox_last = (ArrayList) Tough2Viewer.dataobj.VoroPPData.get(n_of_cells - 1);
                    int IDs_max = (int) singleBox_last.get(0);

                    lineaOUT = "        <DataArray type=\"Float32\" Name=\"ID_T2V_a\" format=\"ascii\" RangeMin=\"" + Integer.toString(IDs_min) + "\" RangeMax=\"" + Integer.toString(IDs_max) + "\">";
                    ps.println(lineaOUT);
                    lineaOUT = "          ";
                    i_tmp = 0;
                    for (int j = 0; j < n_of_cells; j++) {
                        ArrayList singleBox = (ArrayList) Tough2Viewer.dataobj.VoroPPData.get(j);
                        int Ids = (int) singleBox.get(0);
                        lineaOUT = lineaOUT + Integer.toString(Ids) + " ";
                        i_tmp++;
                        if (i_tmp == 5) {
                            ps.println(lineaOUT);
                            lineaOUT = "          ";
                            i_tmp = 0;
                        }
                    }
                    ps.println(lineaOUT);
                    lineaOUT = "        </DataArray>";
                    ps.println(lineaOUT);
                    /////////////////
                    ////////////////
                    //    lineaOUT="      </CellData>";
                    //    ps.println (lineaOUT);
                }
                if (Tough2Viewer.dataobj.get_dataLoaded()) {
                    int number_of_variables = Tough2Viewer.dataobj.get_number_of_variables();

                    String[] var = Tough2Viewer.dataobj.getVariableName();
                    for (int i_v = 0; i_v < number_of_variables; i_v++) {

                        float[] variableMinMax = new float[4];

                        variableMinMax[0] = Tough2Viewer.dataobj.get_GlobalScale(i_v, 0);
                        variableMinMax[1] = Tough2Viewer.dataobj.get_GlobalScale(i_v, 1);

                        lineaOUT = "        <DataArray type=\"Float32\" Name=\"" + var[i_v] + "\" format=\"ascii\" RangeMin=\"" + Double.toString(variableMinMax[0]) + "\" RangeMax=\"" + Double.toString(variableMinMax[1]) + "\">";
                        ps.println(lineaOUT);
                        lineaOUT = "          ";
                        int i_tmp = 0;
                        for (int j = 0; j < n_of_cells; j++) {
                            float value = Tough2Viewer.dataobj.get_dataArray(j, i_t, i_v);

                            lineaOUT = lineaOUT + Double.toString(value) + " ";
                            i_tmp++;
                            if (i_tmp == 5) {
                                ps.println(lineaOUT);
                                lineaOUT = "          ";
                                i_tmp = 0;
                            }
                        }
                        ps.println(lineaOUT);
                        lineaOUT = "        </DataArray>";
                        ps.println(lineaOUT);
                    }

                    if (Tough2Viewer.dataobj.FluxFound) {
                        Tough2Viewer.dataobj.CreateVectorData3D();

                        String[] fluxname = Tough2Viewer.dataobj.getFLOWName();
                        for (int iv = 0; iv < Tough2Viewer.dataobj.get_number_of_flux_variables(); iv++) {
                            lineaOUT = "        <DataArray type=\"Float32\" Name=\"" + fluxname[iv] + "\" NumberOfComponents=\"3\" format=\"ascii\"> ";
                            ps.println(lineaOUT);
                            for (int j = 0; j < n_of_cells; j++) {
                                double x1 = Tough2Viewer.dataobj.get_VectorDataArray(j, i_t, iv * 3 + 0);
                                double y1 = Tough2Viewer.dataobj.get_VectorDataArray(j, i_t, iv * 3 + 1);
                                double z1 = Tough2Viewer.dataobj.get_VectorDataArray(j, i_t, iv * 3 + 2);
                                lineaOUT = "           " + Double.toString(x1) + " " + Double.toString(y1) + " " + Double.toString(z1);
                                ps.println(lineaOUT);
                            }
                            lineaOUT = "        </DataArray>";
                            ps.println(lineaOUT);
                        }
                    }

                }
                if (Tough2Viewer.dataobj.mesh_file_is_loaded)//this imply that we have no output data...
                {
                    lineaOUT = "      </CellData>";
                    ps.println(lineaOUT);
                }
                lineaOUT = "      <Points>";
                ps.println(lineaOUT);
                double rangemax = Math.sqrt((xmax - xmin) * (xmax - xmin) + (ymax - ymin) * (ymax - ymin) + (zmax - zmin) * (zmax - zmin));
                lineaOUT = "        <DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"" + Double.toString(rangemax) + "\">";
                ps.println(lineaOUT);

                //starting write vertex
                //we write also duplicates...
                for (int j = 0; j < n_of_cells; j++) {
                    ArrayList singleBox = (ArrayList) data.get(j);
                    int num_vertex = (Integer) singleBox.get(2);
                    double[] centerD = (double[]) singleBox.get(1);//POS=1
                    num_vertex = (Integer) singleBox.get(2);
                    Point3d[] vertex = new Point3d[num_vertex];
                    for (int i = 0; i < num_vertex; i++) {
                        double[] v = (double[]) singleBox.get(3 + i);
                        vertex[i] = new Point3d(v[0] + centerD[0], v[1] + centerD[1], v[2] + centerD[2]);
                        lineaOUT = "          " + Double.toString(vertex[i].x) + " " + Double.toString(vertex[i].y) + " " + Double.toString(vertex[i].z);
                        ps.println(lineaOUT);
                    }
                }
                //startin write faces
                //faces start from 0....
                lineaOUT = "        </DataArray>";
                ps.println(lineaOUT);
                lineaOUT = "      </Points>";
                ps.println(lineaOUT);
                lineaOUT = "      <Cells>";
                ps.println(lineaOUT);
                lineaOUT = "        <DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"" + Integer.toString(total_vertex - 1) + "\">";
                ps.println(lineaOUT);
                int i_tmp = 0;
                lineaOUT = "          ";
                for (int i = 0; i < total_vertex; i++) {
                    lineaOUT = lineaOUT + Integer.toString(i) + " ";
                    i_tmp++;
                    if (i_tmp == 5) {
                        ps.println(lineaOUT);
                        lineaOUT = "          ";
                        i_tmp = 0;
                    }

                }
                ps.println(lineaOUT);
                lineaOUT = "        </DataArray>";
                ps.println(lineaOUT);
                int min_pointOffset = (Integer) pointOffset.get(0);
                int max_pointOffset = (Integer) pointOffset.get(pointOffset.size() - 1);
                lineaOUT = "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\" RangeMin=\"" + Integer.toString(min_pointOffset) + "\" RangeMax=\"" + Integer.toString(max_pointOffset) + "\">";
                ps.println(lineaOUT);
                i_tmp = 0;
                lineaOUT = "          ";
                for (int i = 0; i < pointOffset.size(); i++) {
                    int pointoffset = (Integer) pointOffset.get(i);
                    lineaOUT = lineaOUT + Integer.toString(pointoffset) + " ";
                    i_tmp++;
                    if (i_tmp == 5) {
                        ps.println(lineaOUT);
                        lineaOUT = "          ";
                        i_tmp = 0;
                    }
                }
                ps.println(lineaOUT);
                lineaOUT = "        </DataArray>";
                ps.println(lineaOUT);
                lineaOUT = "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\" RangeMin=\"42\" RangeMax=\"42\">";
                ps.println(lineaOUT);
                i_tmp = 0;
                lineaOUT = "          ";
                for (int i = 0; i < n_of_cells; i++) {
                    lineaOUT = lineaOUT + "42 ";
                    i_tmp++;
                    if (i_tmp == 5) {
                        ps.println(lineaOUT);
                        lineaOUT = "          ";
                        i_tmp = 0;
                    }
                }
                ps.println(lineaOUT);

                lineaOUT = "        </DataArray>";
                ps.println(lineaOUT);

                lineaOUT = "        <DataArray type=\"Int32\" Name=\"faces\" format=\"ascii\" RangeMin=\"0\" RangeMax=\"" + Integer.toString(rangemax_faces) + "\">";
                ps.println(lineaOUT);

                /////////////////////////////////////////
                global_index = 0;
                for (int j = 0; j < n_of_cells; j++) {
                    ArrayList singleBox = (ArrayList) data.get(j);
                    int num_vertex = (Integer) singleBox.get(2);
                    int number_of_faces = (Integer) singleBox.get(3 + num_vertex);
                    lineaOUT = "      " + Integer.toString(number_of_faces);
                    for (int i = 0; i < number_of_faces; i++) {
                        //COMPLETARE QUI
                        int[] indexs = (int[]) singleBox.get(4 + num_vertex + i);
                        //ora so quanti vertici ha questa faccia:
                        int n_vertex_of_face = indexs.length;
                        lineaOUT = lineaOUT + " " + Integer.toString(n_vertex_of_face) + " ";
                        for (int j1 = 0; j1 < n_vertex_of_face; j1++) {
                            int tmp_faces = global_index + indexs[j1];
                            lineaOUT = lineaOUT + Integer.toString(tmp_faces) + " ";

                        }
                        ps.println(lineaOUT);
                        lineaOUT = "      ";
                    }
                    global_index = global_index + num_vertex;

                }
                //////////////////////////////////////////////
                lineaOUT = "        </DataArray>";
                ps.println(lineaOUT);
                int min_faceOffset = (Integer) faceOffset.get(0);
                int max_faceOffset = (Integer) faceOffset.get(faceOffset.size() - 1);

                lineaOUT = "        <DataArray type=\"Int32\" Name=\"faceoffsets\" format=\"ascii\" RangeMin=\"" + Integer.toString(min_faceOffset) + "\" RangeMax=\"" + Integer.toString(max_faceOffset) + "\">";
                ps.println(lineaOUT);
                i_tmp = 0;
                lineaOUT = "          ";
                for (int i = 0; i < faceOffset.size(); i++) {
                    int facetoffset = (Integer) faceOffset.get(i);
                    lineaOUT = lineaOUT + Integer.toString(facetoffset) + " ";
                    i_tmp++;
                    if (i_tmp == 5) {
                        ps.println(lineaOUT);
                        lineaOUT = "          ";
                        i_tmp = 0;
                    }
                }
                ps.println(lineaOUT);
                lineaOUT = "        </DataArray>";
                ps.println(lineaOUT);
                lineaOUT = "      </Cells>";
                ps.println(lineaOUT);
                lineaOUT = "    </Piece>";
                ps.println(lineaOUT);
                lineaOUT = "  </UnstructuredGrid>";
                ps.println(lineaOUT);
                lineaOUT = "</VTKFile>";
                ps.println(lineaOUT);

                fos.close();
            } // Catches any error conditions
            catch (IOException e) {
                String output = "Unable to write out.vtu file";
                Tough2Viewer.toLogFile(output);
                JOptionPane.showMessageDialog(null, output);
            }
        }
        String message = "Writing files out_n_" + suffix + " OK!!";
        JOptionPane.showMessageDialog(null, message);
        //Open an output stream
        try {
            String filePVD = FilePathString + "\\out.pvd";
            FileOutputStream fos = new FileOutputStream(filePVD, false);
            //DataOutputStream dos = new DataOutputStream(fos);
            PrintStream ps;
            // Print a line of text
            ps = new PrintStream(fos);
            String lineaOUT = "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">";
            ps.println(lineaOUT);
            lineaOUT = "     <Collection>";
            ps.println(lineaOUT);
            for (int i = 0; i < time_steps; i++) {
                String time_i = Float.toString(Tough2Viewer.dataobj.get_Times(i));
                lineaOUT = "          <DataSet timestep=\"" + time_i + "\" file=\'out_" + Integer.toString(i) + ".vtu\'/>";
                ps.println(lineaOUT);
            }
            lineaOUT = "     </Collection>";
            ps.println(lineaOUT);
            lineaOUT = "</VTKFile>";
            ps.println(lineaOUT);
            fos.close();

        } catch (IOException e) {
            String output = "Unable to write out.vtu file";
            Tough2Viewer.toLogFile(output);
            JOptionPane.showMessageDialog(null, output);
        }

    }//GEN-LAST:event_jButton5ActionPerformed
    public void readINIFile() {

        File file = new File("voro_pp.ini");
        boolean exists = (file).exists();
        if (exists) {
            FileInputStream fis = null;
            BufferedInputStream bis = null;
            DataInputStream dis = null;
            try {
                fis = new FileInputStream(file);
                bis = new BufferedInputStream(fis);
                dis = new DataInputStream(bis);
                tough2viewer_dat_file_name = (String) dis.readLine();
                MESH_file_name = (String) dis.readLine();
                T2_data_file_name = (String) dis.readLine();
                INCON_file_name = (String) dis.readLine();
                fis.close();
                bis.close();
                dis.close();
            } catch (IOException e) {
                //e.printStackTrace();
                Tough2Viewer.toLogFile("File ini not found");
            }
        } else {
            String error = "Warning: File voro_pp.ini not found.";
            JOptionPane.showMessageDialog(null, error);
            Tough2Viewer.toLogFile("File ini not found");
        }
        //start reading all files...
        if (!"none".equals(tough2viewer_dat_file_name)) {
            File tough2viewer_dat = new File(tough2viewer_dat_file_name);
            Tough2Viewer.dataobj.tough2viewerdatfile = new ArrayList();
            if (read_tough2viewer_file(tough2viewer_dat)) {
                Preview.setEnabled(true);
                jBtnMesh.setEnabled(true);
                jButton3.setEnabled(true);
                jButton4.setEnabled(true);
                Tough2Viewer.dataobj.VoroPPData = data;
                Tough2Viewer.dataobj.ID_grid_type = 2;
                Tough2Viewer.dataobj.set_WorkingPath(tough2viewer_dat_file_name);
            }
        }
        if (!"none".equals(MESH_file_name)) {
            File Mesh_file = new File(MESH_file_name);
            Tough2Viewer.dataobj.set_InFileName(Mesh_file.getAbsolutePath());
            if (Tough2Viewer.dataobj.read_MESH_file(Mesh_file, 2))//2:VORO++ mesh
            {

                jBtnMesh.setEnabled(false);
                jButtonTough2file.setEnabled(true);
                Tough2Viewer.dataobj.ID_grid_type = 2;
                jButtonTough2file.setEnabled(true);
                jButton2.setEnabled(true);
                jButton4.setEnabled(true);
                Tough2Viewer.dataobj.set_WorkingPath(MESH_file_name);
            }
        }
        if (!"none".equals(T2_data_file_name)) {
            //start to read file
            ReadDataFileActivity1 readactivity = new ReadDataFileActivity1(10, T2_data_file_name, jProgressBar1);
            readactivity.execute();
            Tough2Viewer.dataobj.ID_grid_type = 2;
            Tough2Viewer.dataobj.set_dataLoaded(true);
            Tough2Viewer.dataobj.initializeRockType();
            toINIPathFile();
            jButtonIncon.setEnabled(true);
            Tough2Viewer.dataobj.set_WorkingPath(T2_data_file_name);
        } else {
            CreateEmptyModel();
        }
        if (!"none".equals(INCON_file_name)) {
            //start to read file
            File inconfile = new File(INCON_file_name);
            if (!Tough2Viewer.dataobj.read_INCON_file(inconfile, 0)) {
                String error = "Read INCON error...";
                JOptionPane.showMessageDialog(null, error);

            }
            toINIPathFile();
            jButtonIncon.setEnabled(true);

        } else {
            CreateEmptyModel();
        }

    }
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        readINIFile();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        to_VORO_PP_INI_File();
        this.setVisible(false);
    }//GEN-LAST:event_jButton6ActionPerformed
    public void to_VORO_PP_INI_File() {
        String strFilePath = "voro_pp.ini";
        try {
            // Open an output stream
            FileOutputStream fos = new FileOutputStream(strFilePath, false);
            PrintStream ps;
            // Print a line of text
            ps = new PrintStream(fos);
            ps.println(tough2viewer_dat_file_name);
            ps.println(MESH_file_name);
            ps.println(T2_data_file_name);
            ps.println(INCON_file_name);
            fos.close();
        } // Catches any error conditions
        catch (IOException e) {
            String output = "voro_pp.ini";
            Tough2Viewer.toLogFile(output);
            System.exit(-1);
        }

    }

    public void showFileDataChooser() {
        final JFileChooser fc = new JFileChooser(FilePathString);
        fc.setDialogTitle("Open out");
        int returnVal = fc.showOpenDialog(InputBoxVoroPlusPlus.this);
        final File file;
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            file = fc.getSelectedFile();
            FilePathString = fc.getCurrentDirectory().toString();
            final String FilePath = file.getAbsolutePath();
            //jTextField1.setText(FilePath);

            ReadDataFileActivity readactivity = new ReadDataFileActivity(10, FilePath, jProgressBar1);
            readactivity.execute();

            String fileName = file.getName();
            Tough2Viewer.dataobj.set_DataFileName(fileName);
            FilePathString = FilePath.substring(0, FilePath.length() - fileName.length());
            //jTextField1.setText(FilePath);
            Tough2Viewer.dataobj.set_DataFilePath(FilePathString);
            Tough2Viewer.dataobj.ID_grid_type = 2;
            Tough2Viewer.tough2viewerGUI.UpdateFileInformation();

        }
    }

    private void Convert2MESH(File file) {
        dataMESH.clear();
        FileInputStream fis;
        InputStreamReader InStrReader;
        BufferedReader dis;
        String linea;
        try {

            fis = new FileInputStream(file);
            InStrReader = new InputStreamReader(fis);
            dis = new BufferedReader(InStrReader);
            while ((linea = dis.readLine()) != null) {
                ParseMESHLine(linea);
            }
            dis.close();
//            for(int i=1;i<10;i++)
//            {
//                linea=dis.readLine();
//                
//            }
            int ok = 1;
            block_names = new String[dataMESH.size()];
            block_index = new int[dataMESH.size()];
            for (int i = 0; i < dataMESH.size(); i++) {
                ArrayList temp = (ArrayList) dataMESH.get(i);
                block_names[i] = (String) temp.get(0);
                block_index[i] = i;
            }
            Quicksort.quicksort(block_names, block_index);
            GenerateMESH();
        } catch (Exception ex) {

        }
    }

    private boolean read_tough2viewer_file(File file) {

        FileInputStream fis;
        InputStreamReader InStrReader;
        BufferedReader dis;
        String linea;
        try {
            fis = new FileInputStream(file);
            InStrReader = new InputStreamReader(fis);
            dis = new BufferedReader(InStrReader);
            while ((linea = dis.readLine()) != null) {
                Tough2Viewer.dataobj.tough2viewerdatfile.add(linea);
                ParseLine(linea);
            }
            dis.close();
            int ok = 1;
        } catch (Exception ex) {
            return false;
        }
        //
        //
        //
        //
        Tough2Viewer.dataobj.set_xmin((float) xmin);
        Tough2Viewer.dataobj.set_xmax((float) xmax);
        Tough2Viewer.dataobj.set_ymin((float) ymin);
        Tough2Viewer.dataobj.set_ymax((float) ymax);
        Tough2Viewer.dataobj.set_zmin((float) zmin);
        Tough2Viewer.dataobj.set_zmax((float) zmax);
        Tough2Viewer.dataobj.set_INIT_ROI();
        return true;
    }

    private void ParseLine(String linea) {
        String[] parsedLine = JoeStringUtils1.parseSpace(linea);
        ////////////////////////////////////////
        //
        // Coded added by: 
        // Author   : Stefano Bondua' (DICAM / University of Bologna (Italy)
        // Email    : stefano.bondua@unibo.it
        // Date     : June 28th 2012
        //
        ////////////////////////////////////////
        //TOUGH2VIEWER CUSTOMIZED OUTPUT
        ////////////////////////////////////////
        //i=ID
        //q=x,y,z
        //w=number of vertex
        //p=A list of the vertices of the Voronoi cell in the format (x,y,z), relative to the particle center.
        //s=n faces
        //t=A list of bracketed sequences of vertices that make up each face
        //l=A list of normal vectors for each face.
        ///////////////////////////////////////
        ArrayList BoxData = new ArrayList();
        BoxData.add(Integer.parseInt(parsedLine[0]));//ID//POS=0
        double[] x = new double[3];
        x[0] = Double.parseDouble(parsedLine[1]);//x
        x[1] = Double.parseDouble(parsedLine[2]);//y
        x[2] = Double.parseDouble(parsedLine[3]);//z

        Tough2Viewer.dataobj.xmin_node = Math.min(Tough2Viewer.dataobj.xmin_node, x[0]);
        Tough2Viewer.dataobj.ymin_node = Math.min(Tough2Viewer.dataobj.ymin_node, x[1]);
        Tough2Viewer.dataobj.zmin_node = Math.min(Tough2Viewer.dataobj.zmin_node, x[2]);
        Tough2Viewer.dataobj.xmax_node = Math.max(Tough2Viewer.dataobj.xmax_node, x[0]);
        Tough2Viewer.dataobj.ymax_node = Math.max(Tough2Viewer.dataobj.ymax_node, x[1]);
        Tough2Viewer.dataobj.zmax_node = Math.max(Tough2Viewer.dataobj.zmax_node, x[2]);

        BoxData.add(x);//POS=1
        //parse vertex
        //TEST
        //    x=(double[])BoxData.get(1);
        //END TEST
        int number_of_vertex = Integer.parseInt(parsedLine[4]);
        BoxData.add(number_of_vertex);//POS=2
        for (int i = 0; i < number_of_vertex; i++) {
            double[] xv = new double[3];
            String trimmed = parsedLine[5 + i].substring(1, parsedLine[5 + i].length() - 1);
            String[] xx = JoeStringUtils1.parseString(trimmed, ",");
            xv[0] = Double.parseDouble(xx[0]);//x
            xv[1] = Double.parseDouble(xx[1]);//y
            xv[2] = Double.parseDouble(xx[2]);//z
            xmin = Math.min(xmin, xv[0] + x[0]);
            ymin = Math.min(ymin, xv[1] + x[1]);
            zmin = Math.min(zmin, xv[2] + x[2]);
            xmax = Math.max(xmax, xv[0] + x[0]);
            ymax = Math.max(ymax, xv[1] + x[1]);
            zmax = Math.max(zmax, xv[2] + x[2]);
            BoxData.add(xv);//pos=3+i
        }
        //parse FACE
        int number_of_faces = Integer.parseInt(parsedLine[5 + number_of_vertex]);
        BoxData.add(number_of_faces);//POS=4+number_of_vertex
        for (int i = 0; i < number_of_faces; i++) {
            String trimmed = parsedLine[6 + number_of_vertex + i].substring(1, parsedLine[6 + number_of_vertex + i].length() - 1);
            String[] ii = JoeStringUtils1.parseString(trimmed, ",");
            int n_of_v_for_face = ii.length;
            int[] ii_index = new int[n_of_v_for_face];
            for (int j = 0; j < n_of_v_for_face; j++) {
                ii_index[j] = Integer.parseInt(ii[j]);
            }
            BoxData.add(ii_index);//POS=5+number_of_vertex+i
        }
        //Parse normals
        for (int i = 0; i < number_of_faces; i++) {
            double[] xn = new double[3];
            String trimmed = parsedLine[6 + i + number_of_vertex + number_of_faces].substring(1, parsedLine[6 + i + number_of_vertex + number_of_faces].length() - 1);
            String[] xx = JoeStringUtils1.parseString(trimmed, ",");
            xn[0] = Double.parseDouble(xx[0]);//x
            xn[1] = Double.parseDouble(xx[1]);//y
            xn[2] = Double.parseDouble(xx[2]);//z
            BoxData.add(xn);//POS=6+number_of_vertex+number_of_faces
        }
        //it is ok?
        data.add(BoxData);
        int ok = 1;
    }

    /**
     * @param args the command line arguments
     */
    private void GenerateMESH() {
        int number_of_blocks = dataMESH.size();

        double[] Volumes = new double[number_of_blocks];
        double[] Surphaces = new double[number_of_blocks];
        double[][] X = new double[number_of_blocks][3];
        ArrayList AllConnections = new ArrayList();
        int n_connections = 0;
        for (int i = 0; i < number_of_blocks; i++) {
            ArrayList BlockArray = (ArrayList) dataMESH.get(i);
            String BlockIndex_str = (String) BlockArray.get(0);
            int BlockIndex = OneBlockSearch(BlockIndex_str);
            if (BlockIndex < 0) {
                //we get a problem
                int ohoh = 1;
            }
            double xyz[] = (double[]) BlockArray.get(1);
            X[BlockIndex][0] = xyz[0];
            X[BlockIndex][1] = xyz[1];
            X[BlockIndex][2] = xyz[2];
        }
        for (int i = 0; i < number_of_blocks; i++) {
            ArrayList BlockArray = (ArrayList) dataMESH.get(i);
            Volumes[i] = (Double) BlockArray.get(2);
            int[] connection = (int[]) BlockArray.get(3);//stored as number:is not so correct
            double[] AreaInterface = (double[]) BlockArray.get(4);
            int n = connection.length;
            int index1 = i;
            for (int j = 0; j < n; j++) {

                if (connection[j] >= 0) {

                    int index2 = OneBlockSearch(Integer.toString(connection[j]));
                    if (index2 < 0) {
                        int hoihoi = -1;
                    }
                    if (index1 > index2) {
                        int temp_i = index1;
                        index1 = index2;
                        index2 = temp_i;
                    }
                    //check if already considered
                    boolean ToBeConsidered = true;
                    for (int k = 0; k < AllConnections.size(); k++) {
                        ArrayList SingleConne = (ArrayList) AllConnections.get(k);
                        int[] conne = (int[]) SingleConne.get(0);

                        if (conne[0] == index1 && conne[1] == index2) {

                            ToBeConsidered = false;

                        }

                    }
                    if (ToBeConsidered) {
                        ArrayList NewConne = new ArrayList();
                        int[] conne = new int[2];
                        conne[0] = index1;
                        conne[1] = index2;

                        NewConne.add(conne);
                        double dx = X[index1][0] - X[index2][0];
                        double dy = X[index1][1] - X[index2][1];
                        double dz = X[index1][2] - X[index2][2];
                        int dir = 1;
                        if (Math.abs(dy) > Math.abs(dx)) {
                            dir = 2;
                        }
                        if (Math.abs(dz) > Math.abs(dx) && Math.abs(dz) > Math.abs(dy)) {
                            dir = 3;
                        }
                        NewConne.add(dir);
                        double d = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        NewConne.add(d / 2.0f);
                        NewConne.add(d / 2.0f);
                        NewConne.add(AreaInterface[j]);
                        //dz=d*cos(fi)
                        double cosfi = 0.0f;
                        if (dz != 0) {
                            cosfi = dz / d;
                        }
                        NewConne.add(cosfi);
                        AllConnections.add(NewConne);

                    }
                } else //is a boundary element
                //we give the surphace to 
                //the surphace element only if it is zmin or zmax
                {
                    if (connection[j] == -2 || connection[j] == -7) {

                        if (index1 > -1)//superfluo
                        {
                            Surphaces[index1] = AreaInterface[j];
                        }

                    }
                }
            }
        }

        try {
            // Open an output stream
            String f_out = FilePathString + "\\" + "MESH";
            FileOutputStream fos = new FileOutputStream(f_out, false);
            PrintStream ps;
            // Print a line of text
            ps = new PrintStream(fos);

            ps.println("ELEME");
            String[] BlockNamesTough2 = generateBlockNames(dataMESH.size());

            for (int i = 0; i < dataMESH.size(); i++) {
                String out;
                out = BlockNamesTough2[i];
                out = out + "          ";
                out = out + "ROCK1";
                String vol = new DecimalFormat("0.00000E00").format(Volumes[i]);
                out = out + vol;
                String sur = new DecimalFormat("0.00000E00").format(Surphaces[i]);
                out = out + sur;
                out = out + "          ";
                for (int j = 0; j < 3; j++) {

                    String myDouble = double2String10(X[i][j]);

                    out = out + myDouble;
                }
                out = out.replace(",", ".");//for international settings
                ps.println(out);
            }
            ps.println(" ");
            ps.println("CONNE");
            for (int i = 0; i < AllConnections.size(); i++) {
                ArrayList thisConnection = (ArrayList) AllConnections.get(i);
                int[] myindex = (int[]) thisConnection.get(0);
                String out = BlockNamesTough2[myindex[0]] + BlockNamesTough2[myindex[1]];
                out = out + "                   ";
                int dir = (Integer) thisConnection.get(1);
                out = out + Integer.toString(dir);
                double d1 = (Double) thisConnection.get(2);
                double d2 = (Double) thisConnection.get(3);
                double a1 = (Double) thisConnection.get(4);
                double cosfi = (Double) thisConnection.get(5);
                String d1_str = double2String10(d1);
                String d2_str = double2String10(d2);
                String a1_str = double2String10(a1);

                String cosfi_str = double2String10(cosfi);;

                out = out + d1_str + d2_str + a1_str + cosfi_str;
                out = out.replace(",", ".");//for international settings
                ps.println(out);
            }
            ps.println("     ");
            fos.close();
        } // Catches any error conditions
        catch (IOException e) {
            String output = "Unable to write file";
            toLogFile(output);
        }
    }

    int searchIndex(String name) {
        int notfound = -101;
        for (int i = 0; i < block_names.length; i++) {
            if (name.equalsIgnoreCase(block_names[i])) {
                return i;
            }
        }
        return notfound;
    }

    String double2String10(double input) {
        String output_str = "";
        if (input <= -1.0f) {
            output_str = new DecimalFormat("0.0000E00").format(input);
        }
        if (input > -1.0f && input < 0.0f) {
            output_str = new DecimalFormat("0.000E00").format(input);
        }
        if (input >= 0.0f && input < 1.0f) {
            output_str = new DecimalFormat("0.0000E00").format(input);
        }
        if (input > 1.0f) {
            output_str = new DecimalFormat("0.00000E00").format(input);
        }
        if (output_str.length() != 10) {
            int hoihoi = 1;
        }
        return output_str;
    }

    String[] generateBlockNames(int n) {
        String BlockNames[] = new String[n];
        int index1 = 0;
        int index2 = 0;
        int index3 = 0;
        int index4 = 0;
        int index5 = 0;
        String[] A1 = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"};
        String[] A2 = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"};
        String[] A3 = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"};
        String[] A4 = {" ", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
        String[] A5 = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"};
        for (int i = 0; i < n; i++) {
            BlockNames[i] = A1[index1] + A2[index2] + A3[index3] + A4[index4] + A5[index5];
            index2++;
            if (index2 >= A2.length) {
                index2 = 0;
                index3++;
                if (index3 >= A3.length) {
                    index3 = 0;
                    index5++;
                    if (index5 >= A5.length) {
                        index5 = 0;
                        index4++;
                        if (index4 >= A4.length) {
                            index4 = 0;
                            index1++;
                            if (index1 >= A1.length) {
                                int someproblemhere = 1;
                            }
                        }
                    }
                }
            }

        }
        return BlockNames;
    }

    private int OneBlockSearch(String blockname) {
        int n = -1;
        int start = 0;
        int end = block_names.length;
        int midle;
        boolean continue_search = true;
        while (continue_search) {
            midle = (int) ((start + end) / 2);
            if (block_names[midle].compareTo(blockname) == 0) {
                return block_index[midle];
            }
            if (midle == start || midle == end) {
                continue_search = false;
            }
            if (block_names[midle].compareTo(blockname) > 0) {
                end = midle;
            } else {
                start = midle;
            }

        }

        return n;
    }

    private void ParseMESHLine(String linea) {
        String[] parsedLine = JoeStringUtils1.parseSpace(linea);
        ////////////////////////////////////////
        //
        // Coded added by: 
        // Author   : Stefano Bondua' (DICAM / University of Bologna (Italy)
        // Email    : stefano.bondua@unibo.it
        // Date     : June 28th 2012
        //
        ////////////////////////////////////////
        //TOUGH2VIEWER CUSTOMIZED OUTPUT
        ////////////////////////////////////////
        //con.print_custom("%i %q %v %s %n %f","tough2.mesh");
        //i=ID
        //q=x,y,z
        //v=volume
        //s=n faces
        //n=neighbourud
        //f=area of each face connection

        ///////////////////////////////////////
        ArrayList BoxData = new ArrayList();
        BoxData.add(parsedLine[0]);//ID//POS=0===COME STRINGA!!!
        double[] x = new double[3];
        x[0] = Double.parseDouble(parsedLine[1]);//x
        x[1] = Double.parseDouble(parsedLine[2]);//y
        x[2] = Double.parseDouble(parsedLine[3]);//z
        BoxData.add(x);//POS=1
        double volume = Double.parseDouble(parsedLine[4]);
        BoxData.add(volume);//POS=2
        int number_of_faces = Integer.parseInt(parsedLine[5]);
        int connection[] = new int[number_of_faces];
        for (int i = 0; i < number_of_faces; i++) {

            connection[i] = Integer.parseInt(parsedLine[6 + i]);//x
        }
        BoxData.add(connection);//POS=3
        double[] interface_area = new double[number_of_faces];
        for (int i = 0; i < number_of_faces; i++) {
            interface_area[i] = Double.parseDouble(parsedLine[6 + number_of_faces + i]);

        }
        BoxData.add(interface_area);

        //parse FACE
        dataMESH.add(BoxData);
        int ok = 1;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(InputBoxVoroPlusPlus.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(InputBoxVoroPlusPlus.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(InputBoxVoroPlusPlus.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(InputBoxVoroPlusPlus.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new InputBoxVoroPlusPlus().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Preview;
    private javax.swing.JButton jBtnMesh;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JButton jButtonConvert2MESH;
    private javax.swing.JButton jButtonIncon;
    private javax.swing.JButton jButtonLoadVoroPlusPlus;
    private javax.swing.JButton jButtonTough2file;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JProgressBar jProgressBar1;
    // End of variables declaration//GEN-END:variables
}
